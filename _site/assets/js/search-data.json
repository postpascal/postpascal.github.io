var store = [{
        "title": "MathJax test Fourier Transform",
        "excerpt":"Fourier Transform: Inverse Fourier Transform: ","categories": ["math"],
        "tags": ["Fourier Transform"],
        "url": "http://localhost:4000/math/test/"
      },{
        "title": "PATH",
        "excerpt":"How to add commands to $PATH in Linux or Mac? What is PATH? PATH is a variable in $ \\star$nix system which tells the command path Option1:Set PATH for your current shell session export PATH=$PATH:/path/to/your/directory  DoneOption2:Change your PATH permanently   Edit your .bash_profile(if you ues Bash) or .zshrc( if using zsh)  add path at the end of the fileexport PATH=$PATH:/path/to/your/directoryORexport PATH=/path/to/your/directory:$PATH  Active your changessource .bash_profileORsource .zshrc  Done","categories": ["linux"],
        "tags": ["path"],
        "url": "http://localhost:4000/linux/path/"
      },{
        "title": "Maximum Likelihood Estimation",
        "excerpt":"Bayesian Rule: $P(D \\mid \\theta) \\Rightarrow$ Likelihood $P(\\theta) \\Rightarrow$ prior $P(\\theta \\mid D) \\Rightarrow$ posterior $P(D) \\Rightarrow$ marginal likelihood Maximum Likelihood Estimation (MLE) AKA:最大似然估计，likelihood AKA: 似然函数 Apply log operation to avoid underflow For instance,if  ","categories": ["math"],
        "tags": ["MLE"],
        "url": "http://localhost:4000/math/mle/"
      },{
        "title": "智能时代",
        "excerpt":"智能时代 出版时间:2017作者:吴军正如书名一样，书里描绘里一个智能的时代。或者说是一个数据驱动的时代。科技的进步来源于人类对自然或或者说是事物的认知。也可以换一种说法，是来源于数据。人类的进步就是数据的积累。人们不断的从数据里总结，学习。从而才能产生知识—-一种对数据加工而得到的结论。人类的早期对数据的收集都比较慢，即没有工具，也没有处理的方法。这也就造成了人类的认知不足。随着时间的发展，数据量渐渐增大，人类可以从数据中提炼，挖掘出有效的信息，根据先验知识或者是由数据驱动。这就是我的工作，有效的挖掘数据的潜在价值，利用数据提取信息，进而用这些信息做一些事。所谓智能，不过是把数据中的信息挖掘出智能。比方说图像分类，人脸识别，声音识别。都是来源于数据，并且对数据加工，提取数据的共性，并且放大那些决定性的差异，然后才进行分类。另外一方面也十分重要，那就是对数据的收集。或者说是制造数据。这是对数据智能的前提。 总的来说，就是用智能改进传统行业，分两步   利用新的硬件收集传统行业的数据，量化传统行业的各个关键部分，对数据收集整理  通过数据对自身的反馈做出改变，并且用数据引领企业。难点：   传统行业，比如养殖业，农业，从事这些行业的人大多文化水平不高，对他们的数据难以收集","categories": ["extraction","reading"],
        "tags": ["AI"],
        "url": "http://localhost:4000/extraction/reading/%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3/"
      },{
        "title": "Machine Learning Tips",
        "excerpt":"Recap of Martin Zinkevich’s blog Best Practices for ML Engineering Before Machine Learning Do machine learning like the great engineer you are, not like the expert you aren't.  Machine learning is all of Engineering.ML is limited, but engineering is not. Engineering’s destiny is to quantify problems then solve it. In this case, the first target is how to quantify problems — Design metrics.   1: Don’t be afraid to launch a product without machine learning.  2: Make metrics design and implementation a priority.  3: Choose machine learning over a complex heuristic.    ML Phase I: Your First Pipeline     4: Keep the first model simple and get the infrastructure right.  5: Test the infrastructure independently from the machine learning.  6: Be careful about dropped data when copying pipelines.  7: Turn heuristics into features, or handle them externally.          stand on giant’s shoulders       Monitoring   8: Know the freshness requirements of your system.          How fast you will lost revenue with time goes by.How open you should update your model         9: Detect problems before exporting models.  10: Watch for silent failures.          Track statistics of Data, before preprocessing and feeds         11: Give feature sets owners and documentation.    Your First Objective     12: Don’t overthink which objective you choose to directly optimize.      13: Choose a simple, observable and attributable metric for your first objective.         14: Starting with an interpretable model makes debugging easier.     15: Separate Spam Filtering and Quality Ranking in a Policy Layer.    ML Phase II: Feature Engineering     16: Plan to launch and iterate.      17: Start with directly observed and reported features as opposed to learned features.     18: Explore with features of content that generalize across contexts.  19: Use very specific features when you can.  20: Combine and modify existing features to create new features in human understandable ways.  21: The number of feature weights you can learn in a linear model is roughly proportional to the amount of data you have.  22: Clean up features you are no longer using.          Unused features create technical debt       Human Analysis of the System   23: You are not a typical end user.  24: Measure the delta between models.  25: When choosing models, utilitarian performance trumps predictive power.  26: Look for patterns in the measured errors, and create new features.  27: Try to quantify observed undesirable behavior.          Quantify bad part and improve it. Again, Metric is the first important thingAt this point, they should do whatever it takes to turn their gripes into solid numbers.         28: Be aware that identical short term behavior does not imply identical long term behavior.    Training-Serving Skew           The best solution is to explicitly monitor it so that system and  data changes don’t introduce skew unnoticed.         29: The best way to make sure that you train like you serve is to save the set of features used at serving time, and then pipe those features to a log to use them at training time.  30: Importance weight sampled data, don’t arbitrarily drop it!  31: Beware that if you join data from a table at training and serving time, the data in the table may change.  32: Reuse code between your training pipeline and your serving pipeline whenever possible.  33: If you produce a model based on the data until January 5th, test the model on the data from January 6th and after.          use next-day data         34: In binary classification for filtering (such as spam detection or determining interesting emails), make small short term sacrifices in performance for very clean data.  35: Beware of the inherent skew in ranking problems.  36: Avoid feedback loops with positional features.  37: Measure Training/Serving Skew.          Training data, validation data, test data(next data), live data.       ML Phase III: Slowed Growth, Optimization Refinement, and Complex Models   38: Don’t waste time on new features if unaligned objectives have become the issue.  39: Launch decisions will depend upon more than one metric.  40: Keep ensembles simple.  41: When performance plateaus, look for qualitatively new sources of information to add rather than refining existing signals.  42: Don’t expect diversity, personalization, or relevance to be as correlated with popularity as you think they are.  43: Your friends tend to be the same across different products. Your interests tend not to be.","categories": ["Machine Learning","Reading","Recap"],
        "tags": ["Tips"],
        "url": "http://localhost:4000/machine%20learning/reading/recap/Machine-Learning-tips/"
      },{
        "title": "Distributed Tensorflow",
        "excerpt":"Terminology   Cluster: A cluster is composed of one or more Tensorflow servers, called tasks.  Job: a group of tasks that have a common roal. For instance, parameters server, worker server.  Task: A task corresponds to a specific TensorFlow server, and typically corresponds to a single process. A task belongs to a particular “job” and is identified by its index within that job’s list of tasks.Multiple Devices on a Single Machine Dependencies:   CUDA: Nvidia’s Compute Unified Device Architecture Library allows developers to call GPUs  cuDNN: CUDA deep neural network library to call CUDA  tensorflow-gpu    CUDA, cuDNN and Tensorflow Managing GPU RAM By default Tensorflow will grab all the RAM in all available GPUs the first time you run a graph, so if you run a second Tensorflow program, Memory error showing up.   One solution is to run each process  on different GPU card.# run script in specific GPU cardCUDA_VISIBLE_DEVICES = 0,1 python3 program.py  Another option is to set a threshold for Tensorflow, which limits the program can only grab a fraction of GPUs’ memory.config = tf.ConfigProto()config.gpu_option.per_process_gpu_memory_fraction = 0.4session = tf.Session(config=config)Placing operations on Devices Using the following code to place operation to a specific device, otherwise it will place to the default device.   Cautions: there is no way to pin nodes on a specific CPUs or a subset CPUS with tf.device(\"/cpu:0\"):    a = tf.Variable(3.0)Multiple Devices Across Multiple Servers   Create a Clusesrcluser_spec = tf.train.ClusterSpec({    \"worker\": [        \"machine-a.example.com:2222\", #/job:worker/task:0        \"machine-b.example.com:2222\" #/job:worker/task:1    ],    \"ps\": [        \"machine-a.example.com:2221\", #/job:ps/task:0    ]})    Distributed Tensorflow   Run a serverserver = tf.train.Server(cluster_spec, job_name=\"worker\",task_index=0)# start first worker task  Use server.join() to wait servers finish  In distribution tensorflow, variables maintain by resource container. In other words, we can access the variable across different sessions and servers. To avoid name clash, we can wrap variables by using tf.variable_scope or tf.container. tf.container is easy to reset and release variables.   Advantages:       Be able to explore a much larger hyperparameter space when fine-tuning your model    Large ensembles of NN efficiently  Parallelizing Neural Network on a  Tensorflow Cluster One Neural Network per device      One client per neural network per device.Each device running similar neural network with different hyperparameters.This solution is perfect for hyperparameter tuning. In-Graph Versus Between-Graph Replication (ensemble)   In-Graph: one client,one graph, one session maintains all stuff, one neural network per device.    In-Graph   Between-Graph: several clients maintain Input, Output and Neural Network. Each Neural network is an individual graph.    Between-GraphModel Parallelism   Separate Neural network Horizontally or Vertically.    Model ParallelismData Parallelism   Each device running same neural network, but feeded different mini-batch data. For each iteration, neural network fetch parameters from PS, then Gradients from each network aggrated to update parameters in PS. There are two main approach, synchronous and asynchronous.  With synchronous updates, the aggregator waits for all gradients to be available before computing the average and applying the result.The downside is faster replica have to wait slower one at every iteration. To make it more efficient, we can update parameters only if a fraction of replicas has finished.  With asynchronous updates, whenever a replica has finished computing the gradients, it immediately uses them to update the model parameters.    Data ParallelismReference:   Distributed Tensorflow: Tensorflow official doc  Echosystem: tensorflow official github project, a integration of tensorflow with other open-source framework  Hands-on Machine Learning with Scikit_Learn &amp; Tensorflow: Chapter 12, Distributing Tensorflow Across Devices and Server","categories": ["Machine Learning","Deep Learning"],
        "tags": ["Tensorflow","Distribution"],
        "url": "http://localhost:4000/machine%20learning/deep%20learning/distributed-tensorflow/"
      },{
        "title": "少年",
        "excerpt":"你曾是少年\t\t\t\t\t\t\tYour browser does not support the audio element.\t\t\t你曾是少年，倔强勇敢不改变；你曾是少年，拌嘴吐槽也争先；你曾是少年，啤酒饺子鸡蛋面；你曾是少年，熬夜看书少睡眠；你曾是少年，周易老庄百家言；你曾是少年，江天万里不挂念；你曾是少年，物化生数都等闲；你曾是少年，追云逐日不自谦；你曾是少年，锦绣河山誓踏遍；你曾是少年，怒马扬尘花看厌；你曾是少年，转身告别不留恋。乘风破浪斩敌前，男儿至死是少年。  ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/recipes/shao-nian/"
      }]
